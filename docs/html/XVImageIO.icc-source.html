<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/home/burschka/XVision2-2.0.0/src/Images/XVImageIO.icc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.0 on Fri Oct 26 00:17:16 2007 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>/home/burschka/XVision2-2.0.0/src/Images/XVImageIO.icc</h1><div class="fragment"><pre>00001 <font class="comment">// *** BEGIN_XVISION2_COPYRIGHT_NOTICE ***</font>
00002 <font class="comment">// *** END_XVISION2_COPYRIGHT_NOTICE ***</font>
00003 
00009 <font class="preprocessor">#ifndef _XVIMAGEIO_ICC_
</font>00010 <font class="preprocessor"></font><font class="preprocessor">#define _XVIMAGEIO_ICC_
</font>00011 <font class="preprocessor"></font>
00012 <font class="preprocessor">#include &lt;XVImageIO.h&gt;</font>
00013 
00014 <font class="preprocessor">#include &lt;iostream&gt;</font>
00015 
00016 <font class="keyword">extern</font> <font class="stringliteral">"C"</font>{
00017 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00018 <font class="preprocessor">#include &lt;string.h&gt;</font>
00019 }
00020 
00021 <font class="preprocessor">#ifndef IRERROR
</font>00022 <font class="preprocessor"></font><font class="preprocessor">#define IRERROR "Image Read Error: "
</font>00023 <font class="preprocessor"></font><font class="preprocessor">#define IWERROR "Image Write Error: "
</font>00024 <font class="preprocessor"></font><font class="preprocessor">#endif
</font>00025 <font class="preprocessor"></font>
00026 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00027 <font class="keywordtype">int</font> XVReadImage(<a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename)<font class="keyword"></font>{
00028 
00029   <font class="keywordtype">char</font>* ext = filename ;
00030   <font class="keywordflow">for</font>( ; *ext != <font class="charliteral">'\0'</font> ; ++ ext );
00031   <font class="keywordflow">for</font>( ; ext != filename &amp;&amp; *ext != <font class="charliteral">'.'</font> ; -- ext );
00032   <font class="keywordflow">if</font>( *ext == <font class="charliteral">'.'</font> ) {
00033     ++ ext ;
00034   }<font class="keywordflow">else</font> {
00035     ext = <font class="stringliteral">"ppm"</font> ; <font class="comment">// default</font>
00036   }
00037 
00038   <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"ppm"</font>)){
00039     <font class="keywordflow">return</font> XVReadPPM(inIM, filename);
00040 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00041 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(ext, <font class="stringliteral">"png"</font>) ) {
00042     <font class="keywordflow">return</font> XVReadPNG(inIM, filename);
00043 <font class="preprocessor">#endif
</font>00044 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00045 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(ext, <font class="stringliteral">"jpg"</font>)){
00046     <font class="keywordflow">return</font> XVReadJPG(inIM, filename);
00047 <font class="preprocessor">#endif
</font>00048 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00049 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"tiff"</font>) || !strcasecmp(ext, <font class="stringliteral">"tif"</font>)){
00050     <font class="keywordflow">return</font> XVReadTIF(inIM, filename);
00051 <font class="preprocessor">#endif
</font>00052 <font class="preprocessor"></font>  }<font class="keywordflow">else</font>{
00053     
00054     <font class="keywordflow">if</font>(XVReadPPM(inIM, filename)){
00055       <font class="keywordflow">return</font> 1;
00056 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00057 <font class="preprocessor"></font>    }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(XVReadPNG(inIM, filename)) {
00058       <font class="keywordflow">return</font> 1;
00059 <font class="preprocessor">#endif
</font>00060 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00061 <font class="preprocessor"></font>    }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(XVReadJPG(inIM, filename)){
00062       <font class="keywordflow">return</font> 1;
00063 <font class="preprocessor">#endif
</font>00064 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00065 <font class="preprocessor"></font>    }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(XVReadTIF(inIM, filename)){
00066       <font class="keywordflow">return</font> 1;
00067 <font class="preprocessor">#endif
</font>00068 <font class="preprocessor"></font>    }
00069     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">"Image type: "</font> &lt;&lt; ext &lt;&lt; <font class="stringliteral">" not supported."</font> &lt;&lt; endl;
00070     <font class="keywordflow">return</font> 0;
00071   }
00072 }
00073 
00074 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00075 <font class="keywordtype">int</font> XVReadImage(<a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename, <font class="keywordtype">char</font>* type)<font class="keyword"></font>{
00076 
00077   <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"ppm"</font>)){
00078     <font class="keywordflow">return</font> XVReadPPM(inIM, filename);
00079 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00080 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(type, <font class="stringliteral">"png"</font>) ) {
00081     <font class="keywordflow">return</font> XVReadPNG(inIM, filename);
00082 <font class="preprocessor">#endif
</font>00083 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00084 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(type, <font class="stringliteral">"jpg"</font>)){
00085     <font class="keywordflow">return</font> XVReadJPG(inIM, filename);
00086 <font class="preprocessor">#endif
</font>00087 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00088 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"tiff"</font>) || !strcasecmp(type, <font class="stringliteral">"tif"</font>)){
00089     <font class="keywordflow">return</font> XVReadTIF(inIM, filename);
00090 <font class="preprocessor">#endif
</font>00091 <font class="preprocessor"></font>  }<font class="keywordflow">else</font>{
00092     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">"Image type: "</font> &lt;&lt; type &lt;&lt; <font class="stringliteral">" not supported."</font> &lt;&lt; endl;
00093     <font class="keywordflow">return</font> 0;
00094   }  
00095 }
00096 
00097 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00098 <font class="keywordtype">int</font> XVWriteImage(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> * filename)<font class="keyword"> </font>{
00099 
00100   <font class="keywordtype">char</font>* ext = filename ;
00101   <font class="keywordflow">for</font>( ; *ext != <font class="charliteral">'\0'</font> ; ++ ext );
00102   <font class="keywordflow">for</font>( ; ext != filename &amp;&amp; *ext != <font class="charliteral">'.'</font> ; -- ext );
00103   <font class="keywordflow">if</font>( *ext == <font class="charliteral">'.'</font> ) {
00104     ++ ext ;
00105   }<font class="keywordflow">else</font> {
00106     ext = <font class="stringliteral">"ppm"</font> ; <font class="comment">// default</font>
00107   }
00108 
00109   <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"ppm"</font>)){
00110     <font class="keywordflow">return</font> XVWritePPM(outIM, filename);
00111 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00112 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(ext, <font class="stringliteral">"png"</font>) ) {
00113     <font class="keywordflow">return</font> XVWritePNG(outIM, filename);
00114 <font class="preprocessor">#endif
</font>00115 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00116 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(ext, <font class="stringliteral">"jpg"</font>)){
00117     <font class="keywordflow">return</font> XVWriteJPG(outIM, filename);
00118 <font class="preprocessor">#endif
</font>00119 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00120 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"tiff"</font>) || !strcasecmp(ext, <font class="stringliteral">"tif"</font>)){
00121     <font class="keywordflow">return</font> XVWriteTIF(outIM, filename);
00122 <font class="preprocessor">#endif
</font>00123 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> {
00124     <font class="keywordflow">return</font> XVWritePPM(outIM, filename);
00125   }
00126 }
00127 
00128 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00129 <font class="keywordtype">int</font> XVWriteImage(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font>* filename, <font class="keywordtype">char</font>* type)<font class="keyword"> </font>{
00130 
00131   <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"ppm"</font>)){
00132     <font class="keywordflow">return</font> XVWritePPM(outIM, filename);
00133 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00134 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(type, <font class="stringliteral">"png"</font>) ) {
00135     <font class="keywordflow">return</font> XVWritePNG(outIM, filename);
00136 <font class="preprocessor">#endif
</font>00137 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00138 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(type, <font class="stringliteral">"jpg"</font>)){
00139     <font class="keywordflow">return</font> XVWriteJPG(outIM, filename);
00140 <font class="preprocessor">#endif
</font>00141 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00142 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"tiff"</font>) || !strcasecmp(type, <font class="stringliteral">"tif"</font>)){
00143     <font class="keywordflow">return</font> XVWriteTIF(outIM, filename);
00144 <font class="preprocessor">#endif
</font>00145 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> {
00146     cerr &lt;&lt; IWERROR &lt;&lt; <font class="stringliteral">"Image type: "</font> &lt;&lt; type &lt;&lt; <font class="stringliteral">" not supported."</font> &lt;&lt; endl;
00147     <font class="keywordflow">return</font> 0;
00148   }
00149 };
00150 
00151 
00152 <font class="comment">//************************************************************</font>
00153 <font class="comment">// PPM CODE</font>
00154 <font class="comment">//************************************************************</font>
00155 
00156 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00157 <font class="keywordtype">int</font> XVWritePPM(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00158   ofstream imageout (name, ios::out | ios::binary);
00159   <font class="keywordflow">if</font> (!imageout) {
00160     <font class="keywordflow">return</font> 0;
00161   }
00162   imageout&lt;&lt;<font class="stringliteral">"P6"</font>&lt;&lt;endl&lt;&lt;outIM.Width()&lt;&lt;<font class="stringliteral">" "</font>&lt;&lt;outIM.Height()&lt;&lt;endl&lt;&lt;<font class="stringliteral">"255"</font>&lt;&lt;endl;
00163   <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> *tempb = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> [outIM.Width()*outIM.Height()*3];
00164   XVImageIterator&lt;T&gt; iter(outIM);
00165   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; iter.end() == <font class="keyword">false</font>; ++iter) {
00166       tempb[j++] = (*iter).R();
00167       tempb[j++] = (*iter).G();
00168       tempb[j++] = (*iter).B();
00169   }
00170   imageout.write((<font class="keywordtype">char</font>*)tempb, outIM.Width()*outIM.Height()*3);
00171   imageout.flush();
00172   imageout.close();
00173   <font class="keyword">delete</font>[] tempb;
00174   <font class="keywordflow">return</font> 1;
00175 };
00176 
00177 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00178 <font class="keywordtype">int</font> XVWritePPM(<font class="keyword">const</font> <a class="code" href="class_XVImageYUV.html">XVImageYUV</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00179   ofstream imageout (name, ios::out | ios::binary);
00180   <font class="keywordflow">if</font> (!imageout) {
00181     <font class="keywordflow">return</font> 0;
00182   }
00183   imageout&lt;&lt;<font class="stringliteral">"P6"</font>&lt;&lt;endl&lt;&lt;outIM.Width()&lt;&lt;<font class="stringliteral">" "</font>&lt;&lt;outIM.Height()&lt;&lt;endl&lt;&lt;<font class="stringliteral">"255"</font>&lt;&lt;endl;
00184   <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> *tempb = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> [outIM.Width()*outIM.Height()*3];
00185   XVImageIterator&lt;T&gt; iter(outIM);
00186   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; iter.end() == <font class="keyword">false</font>; ++iter) {
00187       tempb[j++] = (*iter).Y();
00188       tempb[j++] = (*iter).U();
00189       tempb[j++] = (*iter).V();
00190   }
00191   imageout.write((<font class="keywordtype">char</font>*)tempb, outIM.Width()*outIM.Height()*3);
00192   imageout.flush();
00193   imageout.close();
00194   <font class="keyword">delete</font>[] tempb;
00195   <font class="keywordflow">return</font> 1;
00196 };
00197 
00198 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00199 <font class="keywordtype">int</font> XVReadPPM(<a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00200   ifstream imagein (name, ios::in | ios::binary);
00201   <font class="keywordtype">int</font> height, width, npix ;
00202   u_char *imbuff;
00203   <font class="keywordtype">int</font> found = 0;
00204   <font class="keywordtype">char</font> buff[80], *token;
00205 
00206   <font class="keywordflow">if</font> (!imagein) {
00207     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" readPPM: Can't open file: "</font> &lt;&lt; name &lt;&lt; endl;
00208     <font class="keywordflow">return</font> 0;
00209   }
00210 
00211   <font class="comment">//Leaf through comments looking for "P6"</font>
00212   <font class="keywordflow">while</font> ((!found) &amp;&amp; (imagein.getline(buff,80) != (<font class="keywordtype">void</font> *)NULL))
00213     found = (strstr(buff,<font class="stringliteral">"P6"</font>) != NULL);
00214 
00215   <font class="keywordflow">if</font> (!found) {
00216     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" readPPM: "</font> &lt;&lt; name &lt;&lt; <font class="stringliteral">" is not a raw PPM file"</font> &lt;&lt; endl;
00217     <font class="keywordflow">return</font> 0;
00218   }
00219   <font class="comment">//Skip over comments</font>
00220   <font class="keywordflow">while</font> ((imagein.getline(buff,80) != (<font class="keywordtype">void</font> *)NULL) &amp;&amp; (buff[0] == <font class="charliteral">'#'</font>));
00221         
00222   <font class="comment">//Assume next line is width/height</font>
00223   token = strtok(buff, <font class="stringliteral">" "</font>);
00224   width = atoi(token);
00225   token = strtok(NULL, <font class="stringliteral">" "</font>);
00226   height = atoi(token);
00227   imagein.getline(buff,80);
00228   inIM.resize(width,height);
00229 
00230   <font class="comment">// Allocate local buffer</font>
00231   imbuff = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>[width*height*3];
00232   npix = imagein.tellg();
00233   
00234   XVImageWIterator&lt;T&gt; iter(inIM);
00235 
00236   imagein.read((<font class="keywordtype">char</font>*)imbuff,width*height*3);
00237   npix = (<font class="keywordtype">int</font>)imagein.tellg()-npix;
00238   <font class="keywordflow">if</font> (npix != (width*height*3)) {
00239     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" readPPM: Corrupt PPM File: "</font> &lt;&lt; name &lt;&lt; endl;
00240     <font class="keywordflow">return</font> 0;
00241   }
00242   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0; !iter.end(); ++iter) {
00243     (*iter).setR(imbuff[i++]);
00244     (*iter).setG(imbuff[i++]);
00245     (*iter).setB(imbuff[i++]);
00246   }
00247   <font class="keyword">delete</font>[] imbuff;
00248   imagein.close();
00249   <font class="keywordflow">return</font> 1;
00250 };
00251 
00252 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00253 <font class="keywordtype">int</font> XVReadPPM(<a class="code" href="class_XVImageYUV.html">XVImageYUV</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00254   ifstream imagein (name, ios::in | ios::binary);
00255   <font class="keywordtype">int</font> height, width, npix ;
00256   u_char *imbuff;
00257   <font class="keywordtype">int</font> found = 0;
00258   <font class="keywordtype">char</font> buff[80], *token;
00259 
00260   <font class="keywordflow">if</font> (!imagein) {
00261     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" readPPM: Can't open file: "</font> &lt;&lt; name &lt;&lt; endl;
00262     <font class="keywordflow">return</font> 0;
00263   }
00264 
00265   <font class="comment">//Leaf through comments looking for "P6"</font>
00266   <font class="keywordflow">while</font> ((!found) &amp;&amp; (imagein.getline(buff,80) != (<font class="keywordtype">void</font> *)NULL))
00267     found = (strstr(buff,<font class="stringliteral">"P6"</font>) != NULL);
00268 
00269   <font class="keywordflow">if</font> (!found) {
00270     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" readPPM: "</font> &lt;&lt; name &lt;&lt; <font class="stringliteral">" is not a raw PPM file"</font> &lt;&lt; endl;
00271     <font class="keywordflow">return</font> 0;
00272   }
00273   <font class="comment">//Skip over comments</font>
00274   <font class="keywordflow">while</font> ((imagein.getline(buff,80) != (<font class="keywordtype">void</font> *)NULL) &amp;&amp; (buff[0] == <font class="charliteral">'#'</font>));
00275         
00276   <font class="comment">//Assume next line is width/height</font>
00277   token = strtok(buff, <font class="stringliteral">" "</font>);
00278   width = atoi(token);
00279   token = strtok(NULL, <font class="stringliteral">" "</font>);
00280   height = atoi(token);
00281   imagein.getline(buff,80);
00282   inIM.resize(width,height);
00283 
00284   <font class="comment">// Allocate local buffer</font>
00285   imbuff = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>[width*height*3];
00286   npix = imagein.tellg();
00287   
00288   XVImageWIterator&lt;T&gt; iter(inIM);
00289 
00290   imagein.read((<font class="keywordtype">char</font>*)imbuff,width*height*3);
00291   npix = (<font class="keywordtype">int</font>)imagein.tellg()-npix;
00292   <font class="keywordflow">if</font> (npix != (width*height*3)) {
00293     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" readPPM: Corrupt PPM File: "</font> &lt;&lt; name &lt;&lt; endl;
00294     <font class="keywordflow">return</font> 0;
00295   }
00296   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0; !iter.end(); ++iter) {
00297     (*iter).setY(imbuff[i++]);
00298     (*iter).setU(imbuff[i++]);
00299     (*iter).setV(imbuff[i++]);
00300   }
00301   <font class="keyword">delete</font>[] imbuff;
00302   imagein.close();
00303   <font class="keywordflow">return</font> 1;
00304 };
00305 
00306 <font class="preprocessor">#ifdef JPEG_LIB
</font>00307 <font class="preprocessor"></font>
00308 <font class="comment">//************************************************************</font>
00309 <font class="comment">// JPEG HEADERS</font>
00310 <font class="comment">//************************************************************</font>
00311 
00312 <font class="keyword">extern</font> <font class="stringliteral">"C"</font>{ 
00313 <font class="preprocessor">#include &lt;setjmp.h&gt;</font>
00314 <font class="preprocessor">#include "jpeglib.h"</font>
00315 }
00316 
00317 <font class="comment">//************************************************************</font>
00318 <font class="comment">// C Code for JPEG</font>
00319 <font class="comment">//************************************************************</font>
00320 
00321 <font class="keyword">struct </font>my_error_mgr {
00322   <font class="keyword">struct </font>jpeg_error_mgr pub;  <font class="comment">/* "public" fields */</font>
00323   
00324   jmp_buf setjmp_buffer; <font class="comment">/* for return to caller */</font>
00325 };
00326 
00327 <font class="keyword">typedef</font> <font class="keyword">struct </font>my_error_mgr * my_error_ptr;
00328 
00329 METHODDEF(<font class="keywordtype">void</font>)
00330   my_error_exit (j_common_ptr cinfo)<font class="keyword">
</font>00331 <font class="keyword"></font>{
00332   my_error_ptr myerr = (my_error_ptr) cinfo-&gt;err;
00333   (*cinfo-&gt;err-&gt;output_message) (cinfo);
00334   longjmp(myerr-&gt;setjmp_buffer, 1);
00335 }
00336 
00337 <font class="comment">//************************************************************</font>
00338 <font class="comment">// JPG CODE</font>
00339 <font class="comment">//************************************************************</font>
00340 
00341 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00342 <font class="keywordtype">int</font> XVReadJPG(<a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename)<font class="keyword"></font>{
00343 
00344   FILE * infile;
00345   JSAMPLE  ** buffer;
00346   <font class="keywordtype">int</font> row_stride;
00347 
00348   <font class="keyword">struct </font>jpeg_decompress_struct cinfo;
00349   <font class="keyword">struct </font>my_error_mgr jerr;
00350 
00351   <font class="keywordflow">if</font> ((infile = fopen(filename, <font class="stringliteral">"rb"</font>)) == NULL) {
00352     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" can't open file: "</font> &lt;&lt; filename &lt;&lt; endl;
00353     <font class="keywordflow">return</font> 0;
00354   }
00355   cinfo.err = jpeg_std_error(&amp;jerr.pub);
00356   jerr.pub.error_exit = my_error_exit;
00357 
00358   <font class="keywordflow">if</font> (setjmp(jerr.setjmp_buffer)) {
00359 
00360     jpeg_destroy_decompress(&amp;cinfo);
00361     fclose(infile);
00362     <font class="keywordflow">return</font> 0;
00363   }
00364 
00365   jpeg_create_decompress(&amp;cinfo);
00366   jpeg_stdio_src(&amp;cinfo, infile);
00367   (<font class="keywordtype">void</font>) jpeg_read_header(&amp;cinfo, TRUE);
00368   
00369   (<font class="keywordtype">void</font>) jpeg_start_decompress(&amp;cinfo);
00370   
00371   <font class="keywordflow">if</font>(cinfo.output_components != 3){
00372     
00373     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">"in readJPEG: XVImageRGBFileIO can't open a file"</font> &lt;&lt; endl
00374       &lt;&lt; <font class="stringliteral">"                               without 3 samples per pixel."</font> &lt;&lt; endl
00375          &lt;&lt; <font class="stringliteral">"                               Use XVImageScalar."</font> &lt;&lt; endl;
00376   }
00377 
00378   inIM.resize(cinfo.output_width, cinfo.output_height);
00379   XVImageWIterator&lt;T&gt; iter(inIM);
00380 
00381   row_stride = cinfo.output_width * cinfo.output_components;
00382 
00383   buffer = (*cinfo.mem-&gt;alloc_sarray)
00384           ((j_common_ptr) &amp;cinfo, JPOOL_IMAGE, row_stride, 1);
00385 
00386   <font class="keywordflow">while</font> (cinfo.output_scanline &lt; cinfo.output_height) {
00387 
00388     (<font class="keywordtype">void</font>) jpeg_read_scanlines(&amp;cinfo, buffer, 1);
00389 
00390     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; cinfo.output_width; i++){
00391 
00392       (*iter).setR((*buffer)[i*cinfo.output_components]);
00393       (*iter).setG((*buffer)[i*cinfo.output_components + 1]);
00394       (*iter).setB((*buffer)[i*cinfo.output_components + 2]);
00395       <font class="keywordflow">if</font>( iter.end() ) <font class="keywordflow">break</font>;
00396       ++iter;
00397     }
00398   }
00399 
00400   (<font class="keywordtype">void</font>) jpeg_finish_decompress(&amp;cinfo);
00401   jpeg_destroy_decompress(&amp;cinfo);
00402   fclose(infile);
00403   <font class="keywordflow">return</font> 1;
00404 }
00405 
00406 
00407 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00408 <font class="keywordtype">int</font> XVWriteJPG(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> * filename)<font class="keyword"> </font>{
00409 
00410   <font class="keywordflow">return</font> XVWriteJPG(outIM, filename, 100);
00411 }
00412 
00413 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00414 <font class="keywordtype">int</font> XVWriteJPG(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> * filename, <font class="keywordtype">int</font> quality)<font class="keyword"> </font>{
00415 
00416   <font class="keyword">struct </font>jpeg_compress_struct cinfo;
00417   <font class="keyword">struct </font>jpeg_error_mgr jerr;
00418 
00419   FILE * outfile;        <font class="comment">/* target file */</font>
00420   JSAMPROW row_pointer[1];    <font class="comment">/* pointer to JSAMPLE row[s] */</font>
00421   <font class="keywordtype">int</font> row_stride;        <font class="comment">/* physical row width in image buffer */</font>
00422 
00423   cinfo.err = jpeg_std_error(&amp;jerr);
00424   jpeg_create_compress(&amp;cinfo);
00425 
00426   <font class="keywordflow">if</font> ((outfile = fopen(filename, <font class="stringliteral">"wb"</font>)) == NULL) {
00427     cerr &lt;&lt; IWERROR &lt;&lt; <font class="stringliteral">" writeJPG: can't open "</font> &lt;&lt;  filename &lt;&lt; endl;
00428     <font class="keywordflow">return</font> 0;
00429   }
00430   jpeg_stdio_dest(&amp;cinfo, outfile);
00431 
00432   cinfo.image_width = outIM.Width();
00433   cinfo.image_height = outIM.Height();
00434   cinfo.input_components = 3;      <font class="comment">/* # of color components per pixel */</font>
00435   cinfo.in_color_space = JCS_RGB;  <font class="comment">/* colorspace of input image */</font>
00436   jpeg_set_defaults(&amp;cinfo);
00437 
00438   <font class="comment">// quality must be an int from 0 to 100</font>
00439   jpeg_set_quality(&amp;cinfo, quality, TRUE <font class="comment">/* limit to baseline-JPEG values */</font>);
00440   jpeg_start_compress(&amp;cinfo, TRUE);
00441   row_stride = cinfo.image_width * cinfo.input_components;
00442 
00443   XVImageIterator&lt;T&gt; iter(outIM);
00444 
00445   JSAMPLE * line_buffer;
00446   <font class="keywordflow">while</font> (cinfo.next_scanline &lt; cinfo.image_height) {
00447 
00448     line_buffer  = <font class="keyword">new</font> JSAMPLE[row_stride];
00449     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; cinfo.image_width; i++){
00450 
00451       line_buffer[i*3]     = (JSAMPLE) (*iter).R();
00452       line_buffer[i*3 + 1] = (JSAMPLE) (*iter).G();
00453       line_buffer[i*3 + 2] = (JSAMPLE) (*iter).B();
00454       <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
00455     }
00456 
00457     row_pointer[0] = line_buffer;
00458     (<font class="keywordtype">void</font>) jpeg_write_scanlines(&amp;cinfo, row_pointer, 1);
00459     <font class="keyword">delete</font>[] line_buffer;
00460   }
00461 
00462   jpeg_finish_compress(&amp;cinfo);
00463   fclose(outfile);
00464   jpeg_destroy_compress(&amp;cinfo);
00465   <font class="keywordflow">return</font> 1;
00466 }
00467 
00468 <font class="preprocessor">#endif
</font>00469 <font class="preprocessor"></font>
00470 <font class="preprocessor">#ifdef TIFF_LIB
</font>00471 <font class="preprocessor"></font>
00472 <font class="comment">//************************************************************</font>
00473 <font class="comment">// TIFF HEADERS</font>
00474 <font class="comment">//************************************************************</font>
00475 
00476 <font class="keyword">extern</font> <font class="stringliteral">"C"</font>{
00477 <font class="preprocessor">#include "tiffio.h"</font>
00478 <font class="preprocessor">#define TIFFGetR(abgr)   ((abgr) &amp; 0xff)
</font>00479 <font class="preprocessor"></font><font class="preprocessor">#define TIFFGetG(abgr)   (((abgr) &gt;&gt; 8) &amp; 0xff)
</font>00480 <font class="preprocessor"></font><font class="preprocessor">#define TIFFGetB(abgr)   (((abgr) &gt;&gt; 16) &amp; 0xff)
</font>00481 <font class="preprocessor"></font><font class="preprocessor">#define TIFFGetA(abgr)   (((abgr) &gt;&gt; 24) &amp; 0xff)
</font>00482 <font class="preprocessor"></font>
00483 }
00484 
00485 <font class="comment">//************************************************************</font>
00486 <font class="comment">// TIFF CODE</font>
00487 <font class="comment">//************************************************************</font>
00488 
00489 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00490 <font class="keywordtype">int</font> XVReadTIF(<a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename)<font class="keyword"></font>{ 
00491 
00492   TIFF* tif = TIFFOpen(filename, <font class="stringliteral">"r"</font>);
00493   <font class="keywordflow">if</font> (tif) {
00494     uint32 w, h;
00495     size_t npixels;
00496     uint32* raster;
00497    
00498     TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &amp;w);
00499     TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &amp;h);
00500 
00501     inIM.resize(w, h);
00502     XVImageWIterator&lt;T&gt; iter(inIM);
00503         
00504     npixels = w * h;
00505     raster = (uint32*) _TIFFmalloc(npixels * <font class="keyword">sizeof</font> (uint32));
00506     <font class="keywordflow">if</font> (raster != NULL) {
00507       <font class="keywordflow">if</font> (TIFFReadRGBAImage(tif, w, h, raster, 0)) {
00508      <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j = h - 1; j &gt;= 0; --j){
00509        <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; w; ++i){
00510          (*iter).setR(TIFFGetR(raster[j*w+i]));
00511          (*iter).setG(TIFFGetG(raster[j*w+i]));
00512          (*iter).setB(TIFFGetB(raster[j*w+i]));
00513          <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
00514        }
00515      }
00516       }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
00517       <font class="comment">//      _TIFFfree(raster);</font>
00518     }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
00519     TIFFClose(tif);
00520     <font class="keywordflow">return</font> 1;    
00521   }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
00522 }
00523 
00524 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00525 <font class="keywordtype">int</font> XVWriteTIF(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font>* filename)<font class="keyword"> </font>{ 
00526   
00527   <font class="keywordflow">return</font> XVWriteTIF(outIM, filename, 0);
00528 }
00529 
00530 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00531 <font class="keywordtype">int</font> XVWriteTIF(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font>* filename, <font class="keywordtype">int</font> compress)<font class="keyword"> </font>{ 
00532 
00533   TIFF* tif = TIFFOpen(filename, <font class="stringliteral">"w"</font>);
00534   <font class="keywordflow">if</font>(tif) {
00535     tdata_t buf;
00536     uint32 w, h;
00537     uint16 p;
00538     <font class="keywordtype">char</font> pix[4];
00539 
00540     TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, outIM.Width());
00541     TIFFSetField(tif, TIFFTAG_IMAGELENGTH, outIM.Height());
00542     TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
00543     TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);
00544     TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);
00545     TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 2);
00546     <font class="keywordflow">if</font>(compress){
00547       TIFFSetField(tif, TIFFTAG_COMPRESSION, 32773);
00548     }<font class="keywordflow">else</font>{
00549       TIFFSetField(tif, TIFFTAG_COMPRESSION, 1);
00550     }
00551 
00552     XVImageIterator&lt;T&gt; iter(outIM);
00553 
00554     buf = (<font class="keywordtype">char</font> *)_TIFFmalloc(outIM.Width() * 3);
00555     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j = 0; j &lt; outIM.Height(); j++){
00556       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; outIM.Width(); i++){
00557      
00558      ((<font class="keywordtype">char</font>*)buf)[i*3] = (*iter).R();
00559      ((<font class="keywordtype">char</font>*)buf)[i*3+1] = (*iter).G();
00560      ((<font class="keywordtype">char</font>*)buf)[i*3+2] = (*iter).B();
00561      <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
00562       }
00563       TIFFWriteScanline(tif, buf, j);
00564     }
00565     _TIFFfree(buf);
00566     TIFFClose(tif);
00567   }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
00568 }
00569 
00570 <font class="preprocessor">#endif
</font>00571 <font class="preprocessor"></font>
00572 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00573 <font class="keywordtype">int</font> XVReadImage(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename)<font class="keyword"></font>{
00574 
00575   <font class="keywordtype">char</font>* ext = filename ;
00576   <font class="keywordflow">for</font>( ; *ext != <font class="charliteral">'\0'</font> ; ++ ext );
00577   <font class="keywordflow">for</font>( ; ext != filename &amp;&amp; *ext != <font class="charliteral">'.'</font> ; -- ext );
00578   <font class="keywordflow">if</font>( *ext == <font class="charliteral">'.'</font> ) {
00579     ++ ext ;
00580   }<font class="keywordflow">else</font> {
00581     ext = <font class="stringliteral">"pgm"</font> ; <font class="comment">// default</font>
00582   }
00583 
00584   <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"pgm"</font>)){
00585     <font class="keywordflow">return</font> XVReadPGM(inIM, filename);
00586 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00587 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(ext, <font class="stringliteral">"png"</font>) ) {
00588     <font class="keywordflow">return</font> XVReadPNG(inIM, filename);
00589 <font class="preprocessor">#endif
</font>00590 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00591 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(ext, <font class="stringliteral">"jpg"</font>)){
00592     <font class="keywordflow">return</font> XVReadJPG(inIM, filename);
00593 <font class="preprocessor">#endif
</font>00594 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00595 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"tiff"</font>) || !strcasecmp(ext, <font class="stringliteral">"tif"</font>)){
00596     <font class="keywordflow">return</font> XVReadTIF(inIM, filename);
00597 <font class="preprocessor">#endif
</font>00598 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(ext, <font class="stringliteral">"bin"</font>) ) {
00599     <font class="keywordflow">return</font> XVReadBIN(inIM, filename);
00600   }<font class="keywordflow">else</font>{
00601     
00602     <font class="keywordflow">if</font>(XVReadPGM(inIM, filename)){
00603       <font class="keywordflow">return</font> 1;
00604 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00605 <font class="preprocessor"></font>    }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(XVReadPNG(inIM, filename)) {
00606       <font class="keywordflow">return</font> 1;
00607 <font class="preprocessor">#endif
</font>00608 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00609 <font class="preprocessor"></font>    }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(XVReadJPG(inIM, filename)){
00610       <font class="keywordflow">return</font> 1;
00611 <font class="preprocessor">#endif
</font>00612 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00613 <font class="preprocessor"></font>    }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(XVReadTIF(inIM, filename)){
00614       <font class="keywordflow">return</font> 1;
00615 <font class="preprocessor">#endif
</font>00616 <font class="preprocessor"></font>    }
00617     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">"Image type: "</font> &lt;&lt; ext &lt;&lt; <font class="stringliteral">" not supported."</font> &lt;&lt; endl;
00618     <font class="keywordflow">return</font> 0;
00619   }
00620 }
00621 
00622 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00623 <font class="keywordtype">int</font> XVReadImage(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename, <font class="keywordtype">char</font>* type)<font class="keyword"></font>{
00624 
00625   <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"pgm"</font>)){
00626     <font class="keywordflow">return</font> XVReadPGM(inIM, filename);
00627 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00628 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(type, <font class="stringliteral">"png"</font>) ) {
00629     <font class="keywordflow">return</font> XVReadPNG(inIM, filename);
00630 <font class="preprocessor">#endif
</font>00631 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00632 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(type, <font class="stringliteral">"jpg"</font>)){
00633     <font class="keywordflow">return</font> XVReadJPG(inIM, filename);
00634 <font class="preprocessor">#endif
</font>00635 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00636 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"tiff"</font>) || !strcasecmp(type, <font class="stringliteral">"tif"</font>)){
00637     <font class="keywordflow">return</font> XVReadTIF(inIM, filename);
00638 <font class="preprocessor">#endif
</font>00639 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(type, <font class="stringliteral">"bin"</font>) ) {
00640     <font class="keywordflow">return</font> XVReadBIN(inIM, filename);
00641   }<font class="keywordflow">else</font>{
00642     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">"Image type: "</font> &lt;&lt; type &lt;&lt; <font class="stringliteral">" not supported."</font> &lt;&lt; endl;
00643     <font class="keywordflow">return</font> 0;
00644   }  
00645 }
00646 
00647 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00648 <font class="keywordtype">int</font> XVWriteImage(<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> * filename)<font class="keyword"> </font>{
00649 
00650   <font class="keywordtype">char</font>* ext = filename ;
00651   <font class="keywordflow">for</font>( ; *ext != <font class="charliteral">'\0'</font> ; ++ ext );
00652   <font class="keywordflow">for</font>( ; ext != filename &amp;&amp; *ext != <font class="charliteral">'.'</font> ; -- ext );
00653   <font class="keywordflow">if</font>( *ext == <font class="charliteral">'.'</font> ) {
00654     ++ ext ;
00655   }<font class="keywordflow">else</font> {
00656     ext = <font class="stringliteral">"pgm"</font> ; <font class="comment">// default</font>
00657   }
00658 
00659   <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"pgm"</font>)){
00660     <font class="keywordflow">return</font> XVWritePGM(outIM, filename);
00661 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00662 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(ext, <font class="stringliteral">"png"</font>) ) {
00663     <font class="keywordflow">return</font> XVWritePNG(outIM, filename);
00664 <font class="preprocessor">#endif
</font>00665 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00666 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(ext, <font class="stringliteral">"jpg"</font>)){
00667     <font class="keywordflow">return</font> XVWriteJPG(outIM, filename);
00668 <font class="preprocessor">#endif
</font>00669 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00670 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(ext, <font class="stringliteral">"tiff"</font>) || !strcasecmp(ext, <font class="stringliteral">"tif"</font>)){
00671     <font class="keywordflow">return</font> XVWriteTIF(outIM, filename);
00672 <font class="preprocessor">#endif
</font>00673 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> {
00674     <font class="keywordflow">return</font> XVWritePGM(outIM, filename);
00675   }
00676 }
00677 
00678 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00679 <font class="keywordtype">int</font> XVWriteImage(<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font>* filename, <font class="keywordtype">char</font>* type)<font class="keyword"> </font>{
00680 
00681   <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"pgm"</font>)){
00682     <font class="keywordflow">return</font> XVWritePGM(outIM, filename);
00683 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>00684 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>( !strcasecmp(type, <font class="stringliteral">"png"</font>) ) {
00685     <font class="keywordflow">return</font> XVWritePNG(outIM, filename);
00686 <font class="preprocessor">#endif
</font>00687 <font class="preprocessor"></font><font class="preprocessor">#ifdef JPEG_LIB
</font>00688 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"jpeg"</font>) || !strcasecmp(type, <font class="stringliteral">"jpg"</font>)){
00689     <font class="keywordflow">return</font> XVWriteJPG(outIM, filename);
00690 <font class="preprocessor">#endif
</font>00691 <font class="preprocessor"></font><font class="preprocessor">#ifdef TIFF_LIB
</font>00692 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> <font class="keywordflow">if</font>(!strcasecmp(type, <font class="stringliteral">"tiff"</font>) || !strcasecmp(type, <font class="stringliteral">"tif"</font>)){
00693     <font class="keywordflow">return</font> XVWriteTIF(outIM, filename);
00694 <font class="preprocessor">#endif
</font>00695 <font class="preprocessor"></font>  }<font class="keywordflow">else</font> {
00696     cerr &lt;&lt; IWERROR &lt;&lt; <font class="stringliteral">"Image type: "</font> &lt;&lt; type &lt;&lt; <font class="stringliteral">" not supported."</font> &lt;&lt; endl;
00697     <font class="keywordflow">return</font> 0;
00698   }
00699 };
00700 
00701 
00702 <font class="comment">//************************************************************</font>
00703 <font class="comment">// PGM CODE</font>
00704 <font class="comment">//************************************************************</font>
00705 
00706 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00707 <font class="keywordtype">int</font> XVWritePGM (<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00708   ofstream imageout(name);
00709   <font class="keywordflow">if</font> (!imageout) {
00710     <font class="keywordflow">return</font> 0;
00711   }
00712 
00713   imageout &lt;&lt; <font class="stringliteral">"P5"</font> &lt;&lt; endl 
00714         &lt;&lt; outIM.Width() &lt;&lt; <font class="charliteral">' '</font> &lt;&lt; outIM.Height()
00715         &lt;&lt; endl &lt;&lt; <font class="stringliteral">"255"</font> &lt;&lt; endl;
00716   <font class="keywordtype">int</font> size = outIM.Width()*outIM.Height();
00717   u_char *tempb = <font class="keyword">new</font> u_char[size];
00718   XVImageIterator&lt;T&gt; iter(outIM);  
00719   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0; i&lt;size; ++i, ++iter){
00720     tempb[i] = (u_char)*iter; 
00721   }
00722   imageout.write ((<font class="keywordtype">char</font> *)tempb, size);
00723   imageout.close();
00724   <font class="keyword">delete</font>[] tempb;
00725   <font class="keywordflow">return</font> 1;
00726 };
00727 
00728 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00729 <font class="keywordtype">int</font> XVReadPGM(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00730   ifstream imagein (name, ios::in | ios::binary);
00731   <font class="keywordtype">int</font> height, width, npix, found=0;
00732   u_char *imbuff;
00733   <font class="keywordtype">char</font> buff[80], *token;
00734 
00735   <font class="keywordflow">if</font> (!imagein) {
00736     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">" readPGM: Can't open file: "</font> &lt;&lt; name &lt;&lt; endl;
00737     <font class="keywordflow">return</font> 0;
00738   }
00739 
00740   <font class="comment">//leaf through comments looking for P5</font>
00741   <font class="keywordflow">while</font> ((!found) &amp;&amp; (imagein.getline(buff, 80) != (<font class="keywordtype">void</font> *)NULL))
00742     found = (strstr (buff, <font class="stringliteral">"P5"</font>) != NULL);
00743   <font class="keywordflow">if</font> (!found) {
00744     <font class="keywordflow">return</font> 0;
00745   }
00746 
00747   <font class="comment">//skip over comments</font>
00748   imagein.getline(buff,80);
00749   <font class="keywordflow">while</font> (buff[0]==<font class="charliteral">'#'</font>||buff[0]==<font class="charliteral">'\0'</font>) imagein.getline(buff,80);
00750 
00751   <font class="comment">//assume next line is width/height</font>
00752   token = strtok(buff, <font class="stringliteral">" "</font>);
00753   width = atoi(token);
00754   token = strtok(NULL, <font class="stringliteral">" "</font>);
00755   height = atoi(token);
00756   imagein.getline(buff,80);
00757   inIM.resize(width,height);
00758   <font class="comment">// Allocate local buffer</font>
00759   imbuff = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>[width*height];
00760   <font class="comment">// Get the data</font>
00761   npix = imagein.tellg();
00762 
00763   imagein.read((<font class="keywordtype">char</font>*)imbuff,width*height);
00764   npix = (<font class="keywordtype">int</font>)imagein.tellg()-npix;
00765   <font class="keywordflow">if</font> (npix != (width*height)) {
00766     cerr &lt;&lt; <font class="stringliteral">"Warning: file read truncated before image was finished!"</font> &lt;&lt; endl;
00767     cerr &lt;&lt; npix &lt;&lt; <font class="stringliteral">" of "</font> &lt;&lt; width*height &lt;&lt; <font class="stringliteral">" pixels read."</font> &lt;&lt; endl;
00768   }
00769 
00770   XVImageWIterator&lt;T&gt; iter(inIM);
00771   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0; iter.end() == <font class="keyword">false</font>; ++iter, ++i){
00772     (*iter) = (T)imbuff[i];
00773   }
00774 
00775   <font class="keyword">delete</font>[] imbuff;
00776   imagein.close();
00777   <font class="keywordflow">return</font> 1;
00778 };
00779 
00780 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00781 <font class="keywordtype">int</font> XVWriteBMP(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp;outIM, <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00782   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">short</font> WORD;
00783   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> DWORD;
00784   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> BYTE;
00785 
00786 <font class="preprocessor">  #define DIB_HEADER_MARKER   ((WORD) ('M' &lt;&lt; 8) | 'B')
</font>00787 <font class="preprocessor"></font>
00788   <font class="keyword">typedef</font> <font class="keyword">struct </font>tagBITMAPFILEHEADER{
00789     WORD bfType;
00790     DWORD bfSize;
00791     WORD bfReserved1;
00792     WORD bfReserved2;
00793     DWORD bfOffBits;
00794   }BITMAPFILEHEADER;
00795 
00796   <font class="keyword">typedef</font> <font class="keyword">struct </font>tagBITMAPINFOHEADER{
00797     DWORD biSize;
00798     <font class="keywordtype">int</font> biWidth;
00799     <font class="keywordtype">int</font> biHeight;
00800     WORD biPlanes;
00801     WORD biBitCount;
00802     DWORD biCompression;
00803     DWORD biSizeImage;
00804     <font class="keywordtype">int</font> biXPelsPerMeter;
00805     <font class="keywordtype">int</font> biYPelsPerMeter;
00806     DWORD biClrUsed;
00807     DWORD biClrImportant;
00808   }BITMAPINFOHEADER;
00809 
00810   <font class="keyword">typedef</font> <font class="keyword">struct </font>_RGBQD{
00811     BYTE rgbRed;
00812     BYTE rgbGreen;
00813     BYTE rgbBlue;
00814     BYTE rgbReserved;
00815   }RGBQUAD;
00816 
00817   <font class="keyword">typedef</font> <font class="keyword">struct </font>tagBITMAPINFO{
00818     BITMAPINFOHEADER bmiHeader;
00819     RGBQUAD bmiColors[256];    
00820   }BITMAPINFO;
00821 
00822   <font class="keyword">typedef</font> BITMAPINFO* PBITMAPINFO;
00823   
00824   BITMAPINFOHEADER bmpInfoHeader;
00825   DWORD   numColors;
00826   DWORD   aWidth;
00827   WORD    bmpInfoHeadSize = <font class="keyword">sizeof</font>(BITMAPINFOHEADER);
00828   WORD    RGBQUADSize;
00829   <font class="keywordtype">int</font> bmpFileHeadSize=14;
00830 
00831 
00832   bmpInfoHeader.biSize = 0x28;  <font class="comment">//40 is the size of bmpinfohead</font>
00833   bmpInfoHeader.biWidth = outIM.Width();
00834   bmpInfoHeader.biHeight = outIM.Height();
00835   
00836   <font class="comment">//top down bmp</font>
00837   bmpInfoHeader.biPlanes = 1;
00838   bmpInfoHeader.biBitCount = 8;
00839   bmpInfoHeader.biCompression = 0L;
00840   bmpInfoHeader.biClrImportant=0;
00841   numColors = 256;
00842   
00843   aWidth = (outIM.Width() + 3) /4 *4 ;
00844   bmpInfoHeader.biSizeImage  = aWidth * outIM.Height();
00845   bmpInfoHeader.biXPelsPerMeter=100;
00846   bmpInfoHeader.biYPelsPerMeter=100;
00847   bmpInfoHeader.biClrUsed = 256;
00848 
00849   RGBQUADSize = <font class="keyword">sizeof</font>(RGBQUAD) * numColors;
00850   
00851   PBITMAPINFO pBinfo;
00852   <font class="keywordtype">int</font> bmpInfoSize=bmpInfoHeadSize + RGBQUADSize;
00853   
00854   <font class="keywordflow">if</font>( (pBinfo =  <font class="keyword">new</font> BITMAPINFO ) == NULL) {
00855     <font class="keywordflow">return</font> 0;
00856   }
00857         
00858   memcpy(pBinfo, &amp;bmpInfoHeader, bmpInfoHeadSize);
00859   <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i=0; i&lt;(<font class="keywordtype">int</font>)numColors; i++){
00860     pBinfo-&gt;bmiColors[i].rgbRed = i;
00861     pBinfo-&gt;bmiColors[i].rgbGreen =i;
00862     pBinfo-&gt;bmiColors[i].rgbBlue = i;
00863     pBinfo-&gt;bmiColors[i].rgbReserved = 0;
00864   }
00865 
00866   BITMAPFILEHEADER bmfHdr; 
00867   bmfHdr.bfType = DIB_HEADER_MARKER;  <font class="comment">// "BM"</font>
00868   bmfHdr.bfSize=pBinfo-&gt;bmiHeader.biSizeImage + bmpInfoSize + bmpFileHeadSize;
00869 
00870   bmfHdr.bfReserved1 = 0;
00871   bmfHdr.bfReserved2 = 0;
00872 
00873   bmfHdr.bfOffBits = bmpFileHeadSize + bmpInfoSize;
00874 
00875   <font class="comment">//now write the data</font>
00876   FILE* f=fopen(name, <font class="stringliteral">"w"</font>);
00877   
00878   fwrite( &amp;bmfHdr.bfType, 2, 1, f);
00879   fwrite( &amp;bmfHdr.bfSize, 12,1, f);
00880   fwrite( pBinfo,  bmpInfoSize, 1, f);
00881   <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> *p=(<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>*)( outIM.data() );
00882   
00883   <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = outIM.Height()-1; i &gt; -1; i--)
00884     fwrite(p + i * aWidth, aWidth, 1 , f);
00885   
00886   fclose(f);
00887 
00888   <font class="keyword">delete</font> pBinfo;
00889   
00890   <font class="keywordflow">return</font>(1);
00891 
00892 };
00893 
00894 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
00895 <font class="keywordtype">int</font> XVReadBMP(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt;&amp; inIM , <font class="keywordtype">char</font> *name)<font class="keyword"> </font>{
00896   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">short</font> WORD;
00897   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> DWORD;
00898   <font class="keyword">typedef</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> BYTE;
00899 
00900 <font class="preprocessor">  #define DIB_HEADER_MARKER   ((WORD) ('M' &lt;&lt; 8) | 'B')
</font>00901 <font class="preprocessor"></font>
00902   <font class="keyword">typedef</font> <font class="keyword">struct </font>tagBITMAPFILEHEADER{
00903     WORD bfType;
00904     DWORD bfSize;
00905     WORD bfReserved1;
00906     WORD bfReserved2;
00907     DWORD bfOffBits;
00908   }BITMAPFILEHEADER;
00909 
00910   <font class="keyword">typedef</font> <font class="keyword">struct </font>tagBITMAPINFOHEADER{
00911     DWORD biSize;
00912     <font class="keywordtype">int</font> biWidth;
00913     <font class="keywordtype">int</font> biHeight;
00914     WORD biPlanes;
00915     WORD biBitCount;
00916     DWORD biCompression;
00917     DWORD biSizeImage;
00918     <font class="keywordtype">int</font> biXPelsPerMeter;
00919     <font class="keywordtype">int</font> biYPelsPerMeter;
00920     DWORD biClrUsed;
00921     DWORD biClrImportant;
00922   }BITMAPINFOHEADER;
00923 
00924   <font class="keyword">typedef</font> <font class="keyword">struct </font>_RGBQD{
00925     BYTE rgbRed;
00926     BYTE rgbGreen;
00927     BYTE rgbBlue;
00928     BYTE rgbReserved;
00929   }RGBQUAD;
00930 
00931   <font class="keyword">typedef</font> <font class="keyword">struct </font>tagBITMAPINFO{
00932     BITMAPINFOHEADER bmiHeader;
00933     RGBQUAD bmiColors[256];    
00934   }BITMAPINFO;
00935 
00936   <font class="keyword">typedef</font> BITMAPINFO* PBITMAPINFO;
00937   
00938   
00939   BITMAPINFOHEADER bmpInfoHeader;
00940   BITMAPFILEHEADER bmfHeader;
00941   WORD    bmpInfoHeadSize = <font class="keyword">sizeof</font>(BITMAPINFOHEADER);
00942   <font class="keywordtype">int</font> bmpFileHeadSize=14;
00943 
00944   FILE* f=fopen(name, <font class="stringliteral">"r"</font>);
00945   fread(&amp;bmfHeader.bfType,2,1,f);
00946   fread(&amp;bmfHeader.bfSize,12,1,f);
00947   
00948   <font class="keywordflow">if</font> (bmfHeader.bfType != DIB_HEADER_MARKER){
00949     fprintf(stderr,<font class="stringliteral">"Not a valid BMP file header.\n"</font>);
00950     <font class="keywordflow">return</font> 0;
00951   }
00952   fread(&amp;bmpInfoHeader, bmpInfoHeadSize, 1, f);
00953   <font class="keywordflow">if</font>( bmpInfoHeader.biBitCount !=8 ){
00954     fprintf(stderr,<font class="stringliteral">"bitCount is expected to be 8. Not supported format encountered.\n"</font>);    
00955     <font class="keywordflow">return</font> 0;
00956   }
00957 
00958   <font class="keywordtype">int</font> height=bmpInfoHeader.biHeight;
00959   <font class="keywordtype">int</font> aWidth = (bmpInfoHeader.biWidth + 3) /4 *4 ;
00960  
00961   inIM.resize(bmpInfoHeader.biWidth, height);
00962    
00963   fseek(f, bmfHeader.bfOffBits, 0);
00964   
00965   <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* p=(<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>*) ( inIM.lock() ); 
00966   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = height - 1; i &gt; -1; i--)
00967     fread(p + i * aWidth, aWidth, 1 ,f );
00968 
00969   fclose(f);
00970   inIM.unlock();
00971 
00972   <font class="keywordflow">return</font>(1);
00973 
00974 }; 
00975 
00976 
00977  
00978 <font class="preprocessor">#ifdef JPEG_LIB
</font>00979 <font class="preprocessor"></font>
00980 <font class="comment">//************************************************************</font>
00981 <font class="comment">// JPG CODE</font>
00982 <font class="comment">//************************************************************</font>
00983 
00984 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
00985 <font class="keywordtype">int</font> XVReadJPG(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename)<font class="keyword"></font>{
00986 
00987   FILE * infile;
00988   JSAMPLE  ** buffer;
00989   <font class="keywordtype">int</font> row_stride;
00990 
00991   <font class="keyword">struct </font>jpeg_decompress_struct cinfo;
00992   <font class="keyword">struct </font>my_error_mgr jerr;
00993 
00994   <font class="keywordflow">if</font> ((infile = fopen(filename, <font class="stringliteral">"rb"</font>)) == NULL) {
00995     <font class="keywordflow">return</font> 0;
00996   }
00997   cinfo.err = jpeg_std_error(&amp;jerr.pub);
00998   jerr.pub.error_exit = my_error_exit;
00999 
01000   <font class="keywordflow">if</font> (setjmp(jerr.setjmp_buffer)) {
01001 
01002     jpeg_destroy_decompress(&amp;cinfo);
01003     fclose(infile);
01004     <font class="keywordflow">return</font> 0;
01005   }
01006 
01007   jpeg_create_decompress(&amp;cinfo);
01008   jpeg_stdio_src(&amp;cinfo, infile);
01009   (<font class="keywordtype">void</font>) jpeg_read_header(&amp;cinfo, TRUE);
01010   
01011   <font class="keywordflow">if</font>(cinfo.output_components &gt; 1){
01012     
01013     cerr &lt;&lt; IRERROR &lt;&lt; <font class="stringliteral">"in readJPEG: XVImageScalarFileIO can't open a file"</font> &lt;&lt; endl
01014       &lt;&lt; <font class="stringliteral">"                               with more than 1 sample per pixel."</font> &lt;&lt; endl
01015          &lt;&lt; <font class="stringliteral">"                               Use XVImageRGB."</font> &lt;&lt; endl;
01016     <font class="keywordflow">return</font> 0;
01017   }
01018 
01019   (<font class="keywordtype">void</font>) jpeg_start_decompress(&amp;cinfo);
01020   
01021   inIM.resize(cinfo.output_width, cinfo.output_height);
01022   XVImageWIterator&lt;T&gt; iter(inIM);
01023 
01024   row_stride = cinfo.output_width * cinfo.output_components;
01025 
01026   buffer = (*cinfo.mem-&gt;alloc_sarray)
01027           ((j_common_ptr) &amp;cinfo, JPOOL_IMAGE, row_stride, 1);
01028 
01029   <font class="keywordflow">while</font> (cinfo.output_scanline &lt; cinfo.output_height) {
01030 
01031     (<font class="keywordtype">void</font>) jpeg_read_scanlines(&amp;cinfo, buffer, 1);
01032 
01033     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; cinfo.output_width; i++){
01034 
01035       (*iter) = (*buffer)[i];
01036       <font class="keywordflow">if</font>( iter.end() ) <font class="keywordflow">break</font>;
01037       ++iter;
01038     }
01039   }
01040 
01041   (<font class="keywordtype">void</font>) jpeg_finish_decompress(&amp;cinfo);
01042   jpeg_destroy_decompress(&amp;cinfo);
01043   fclose(infile);
01044   <font class="keywordflow">return</font> 1;
01045 };
01046 
01047 
01048 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
01049 <font class="keywordtype">int</font> XVWriteJPG(<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> * filename)<font class="keyword"> </font>{
01050 
01051   <font class="keywordflow">return</font> XVWriteJPG(outIM, filename, 100);
01052 }
01053 
01054 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt; 
01055 <font class="keywordtype">int</font> XVWriteJPG(<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font> * filename, <font class="keywordtype">int</font> quality)<font class="keyword"> </font>{
01056 
01057   <font class="keyword">struct </font>jpeg_compress_struct cinfo;
01058   <font class="keyword">struct </font>jpeg_error_mgr jerr;
01059 
01060   FILE * outfile;        <font class="comment">/* target file */</font>
01061   JSAMPROW row_pointer[1];    <font class="comment">/* pointer to JSAMPLE row[s] */</font>
01062   <font class="keywordtype">int</font> row_stride;        <font class="comment">/* physical row width in image buffer */</font>
01063 
01064   cinfo.err = jpeg_std_error(&amp;jerr);
01065   jpeg_create_compress(&amp;cinfo);
01066 
01067   <font class="keywordflow">if</font> ((outfile = fopen(filename, <font class="stringliteral">"wb"</font>)) == NULL) {
01068     fprintf(stderr, <font class="stringliteral">"can't open %s\n"</font>, filename);
01069     <font class="keywordflow">return</font> 0;
01070   }
01071   jpeg_stdio_dest(&amp;cinfo, outfile);
01072 
01073   cinfo.image_width = outIM.Width();
01074   cinfo.image_height = outIM.Height();
01075   cinfo.input_components = 1;      <font class="comment">/* # of color components per pixel */</font>
01076   cinfo.in_color_space = JCS_GRAYSCALE; <font class="comment">/* colorspace of input image */</font>
01077   jpeg_set_defaults(&amp;cinfo);
01078 
01079   <font class="comment">// quality must be an int from 0 to 100</font>
01080   jpeg_set_quality(&amp;cinfo, quality, TRUE <font class="comment">/* limit to baseline-JPEG values */</font>);
01081   jpeg_start_compress(&amp;cinfo, TRUE);
01082   row_stride = cinfo.image_width * cinfo.input_components;
01083 
01084   XVImageIterator&lt;T&gt; iter(outIM);
01085 
01086   JSAMPLE * line_buffer;
01087   <font class="keywordflow">while</font> (cinfo.next_scanline &lt; cinfo.image_height) {
01088 
01089     line_buffer  = <font class="keyword">new</font> JSAMPLE[row_stride];
01090     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; cinfo.image_width; i++){
01091 
01092       line_buffer[i]     = (JSAMPLE) (*iter);
01093       ++iter;
01094     }
01095 
01096     row_pointer[0] = line_buffer;
01097     (<font class="keywordtype">void</font>) jpeg_write_scanlines(&amp;cinfo, row_pointer, 1);
01098     <font class="keyword">delete</font>[] line_buffer;
01099   }
01100 
01101   jpeg_finish_compress(&amp;cinfo);
01102   fclose(outfile);
01103   jpeg_destroy_compress(&amp;cinfo);
01104   <font class="keywordflow">return</font> 1;
01105 }
01106 
01107 <font class="preprocessor">#endif
</font>01108 <font class="preprocessor"></font>
01109 <font class="preprocessor">#ifdef TIFF_LIB
</font>01110 <font class="preprocessor"></font>
01111 <font class="comment">//************************************************************</font>
01112 <font class="comment">// TIFF CODE</font>
01113 <font class="comment">//************************************************************</font>
01114 
01115 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01116 <font class="keywordtype">int</font> XVReadTIF(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font>* filename)<font class="keyword"></font>{ 
01117 
01118   TIFF* tif = TIFFOpen(filename, <font class="stringliteral">"r"</font>);
01119   <font class="keywordflow">if</font> (tif) {
01120     uint32 w, h;
01121     size_t npixels;
01122     uint32* raster;
01123    
01124     TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &amp;w);
01125     TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &amp;h);
01126 
01127     inIM.resize(w, h);
01128     XVImageWIterator&lt;T&gt; iter(inIM);
01129     
01130     npixels = w * h;
01131     raster = (uint32*) _TIFFmalloc(npixels * <font class="keyword">sizeof</font> (uint32));
01132     <font class="keywordflow">if</font> (raster != NULL) {
01133       <font class="keywordflow">if</font> (TIFFReadRGBAImage(tif, w, h, raster, 0)) {
01134      <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j = h - 1; j &gt;= 0; --j){
01135        <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; w; ++i){
01136          (*iter) = (<font class="keywordtype">char</font>)(TIFFGetR(raster[j*w+i]));
01137          <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
01138        }
01139      }
01140       }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
01141       _TIFFfree(raster);
01142     }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
01143     TIFFClose(tif);
01144     <font class="keywordflow">return</font> 1;    
01145   }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
01146 }
01147 
01148 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01149 <font class="keywordtype">int</font> XVWriteTIF(<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font>* filename)<font class="keyword"> </font>{
01150   
01151   <font class="keywordflow">return</font> XVWriteTIF(outIM, filename, 0);
01152 }
01153 
01154 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01155 <font class="keywordtype">int</font> XVWriteTIF(<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; outIM, <font class="keywordtype">char</font>* filename, <font class="keywordtype">int</font> compress)<font class="keyword"> </font>{ 
01156 
01157   TIFF* tif = TIFFOpen(filename, <font class="stringliteral">"w"</font>);
01158   <font class="keywordflow">if</font>(tif) {
01159     tdata_t buf;
01160 
01161     TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, outIM.Width());
01162     TIFFSetField(tif, TIFFTAG_IMAGELENGTH, outIM.Height());
01163     TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
01164     TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);
01165     TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);
01166     TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, 0);
01167     <font class="keywordflow">if</font>(compress){
01168       TIFFSetField(tif, TIFFTAG_COMPRESSION, 32773);
01169     }<font class="keywordflow">else</font>{
01170       TIFFSetField(tif, TIFFTAG_COMPRESSION, 1);
01171     }
01172 
01173     XVImageIterator&lt;T&gt; iter(outIM);
01174     
01175     buf = (<font class="keywordtype">char</font> *)_TIFFmalloc(outIM.Width());
01176     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j = 0; j &lt; outIM.Height(); j++){
01177       
01178       <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0; i &lt; outIM.Width(); i++){
01179      
01180      ((<font class="keywordtype">char</font>*)buf)[i] = (<font class="keywordtype">char</font>)(*iter);
01181      <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
01182       }
01183       TIFFWriteScanline(tif, buf, j);
01184     }
01185     _TIFFfree(buf);
01186     TIFFClose(tif);
01187     <font class="keywordflow">return</font> 1 ;
01188   }<font class="keywordflow">else</font>{ <font class="keywordflow">return</font> 0; }
01189 }
01190 
01191 <font class="preprocessor">#endif
</font>01192 <font class="preprocessor"></font>
01193 
01194 <font class="comment">//  BIN code </font>
01195 <font class="comment">//  Somewhat backwards because the width and the height of the image</font>
01196 <font class="comment">//   are known.  i.e. if you have a .BIN file then you should have</font>
01197 <font class="comment">//   already set the dims of the image into which you will read it</font>
01198 <font class="comment">//   based on the known size of the .BIN</font>
01199 
01200 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01201 <font class="keywordtype">int</font> XVReadBIN(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp; inIM, <font class="keywordtype">char</font> *name)<font class="keyword"> 
</font>01202 <font class="keyword"></font>{
01203   FILE *f;
01204 
01205   f = fopen(name,<font class="stringliteral">"rb"</font>);
01206   <font class="keywordflow">if</font> (!f) <font class="keywordflow">return</font> -1;
01207   fread(inIM.lock(),<font class="keyword">sizeof</font>(T),inIM.Width()*inIM.Height(),f);
01208   inIM.unlock();
01209   fclose(f);
01210   <font class="keywordflow">return</font> 1 ;
01211 }
01212 
01213 
01214 <font class="comment">//**************************************************************************</font>
01215 <font class="comment">//* PNG CODE</font>
01216 <font class="comment">//**************************************************************************</font>
01217 
01218 <font class="preprocessor">#ifdef HAVE_LIBPNG
</font>01219 <font class="preprocessor"></font>
01220 <font class="preprocessor">#define PNG_BYTES_TO_CHECK 4
</font>01221 <font class="preprocessor"></font>
01222 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01223 <font class="keywordtype">int</font> XVReadPNG(<a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp;I, <font class="keywordtype">char</font> *fn)<font class="keyword">
</font>01224 <font class="keyword"></font>{
01225   <font class="keywordtype">char</font> buf[PNG_BYTES_TO_CHECK];
01226   png_structp png_ptr;
01227   png_infop info_ptr;
01228   <font class="keywordtype">int</font> bit_depth,  color_type, channels=0;
01229   FILE *fp;
01230 
01231      <font class="comment">// open the file</font>
01232   <font class="keywordflow">if</font> ((fp = fopen(fn, <font class="stringliteral">"rb"</font>)) == NULL)
01233      <font class="keywordflow">return</font> -1;
01234 
01235      <font class="comment">// read the file-type indicator to check if this is a PNG</font>
01236   <font class="keywordflow">if</font> (fread(buf, 1, PNG_BYTES_TO_CHECK, fp) != PNG_BYTES_TO_CHECK)
01237      <font class="keywordflow">return</font> -2;
01238 
01239      <font class="comment">// check if it is a PNG file</font>
01240   <font class="keywordflow">if</font> (png_sig_cmp((png_byte*)buf, (png_size_t)0, PNG_BYTES_TO_CHECK))
01241      <font class="keywordflow">return</font> -3;
01242 
01243   png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
01244   <font class="keywordflow">if</font> (png_ptr == NULL) {
01245      fclose(fp);
01246      <font class="keywordflow">return</font> -4;
01247   }
01248 
01249   info_ptr = png_create_info_struct(png_ptr);
01250   <font class="keywordflow">if</font> (info_ptr == NULL) {
01251     fclose(fp);
01252     png_destroy_read_struct(&amp;png_ptr, png_infopp_NULL, png_infopp_NULL);
01253     <font class="keywordflow">return</font> -5;
01254   }
01255 
01256   <font class="keywordflow">if</font> (setjmp(png_jmpbuf(png_ptr))) {
01257     <font class="comment">// Free all of the memory associated with the png_ptr and info_ptr </font>
01258     png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01259     fclose(fp);
01260     <font class="comment">// If we get here, we had a problem reading the file </font>
01261     <font class="keywordflow">return</font> -6;
01262   }
01263 
01264   png_init_io(png_ptr, fp);
01265   png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK);
01266 
01267   png_uint_32  width, height;
01268 
01269   png_read_info(png_ptr, info_ptr);  
01270 
01271   <font class="comment">// read all PNG info up to image data </font>
01272   png_get_IHDR(png_ptr, info_ptr, &amp;width, &amp;height, &amp;bit_depth, &amp;color_type,
01273       NULL, NULL, NULL);
01274   
01275   I.resize(width,height);
01276 
01277   <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_PALETTE)
01278      png_set_expand(png_ptr);
01279 
01280   <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_GRAY &amp;&amp; bit_depth &lt; 8)
01281      png_set_expand(png_ptr);
01282 
01283   <font class="keywordflow">if</font> (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
01284      png_set_expand(png_ptr);
01285 
01286   <font class="keywordflow">if</font> (bit_depth == 16)
01287      png_set_strip_16(png_ptr);
01288 
01289   <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_GRAY ||
01290      color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
01291      png_set_gray_to_rgb(png_ptr);
01292 
01293   png_read_update_info(png_ptr, info_ptr);
01294 
01295   channels = png_get_channels(png_ptr,info_ptr);
01296 
01297      <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_GRAY ||
01298       color_type == PNG_COLOR_TYPE_RGB  ||
01299          color_type == PNG_COLOR_TYPE_PALETTE) 
01300   {
01301 
01302     <font class="keywordtype">int</font> row_bytes=png_get_rowbytes(png_ptr, info_ptr);
01303     <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>*  image_data = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>[row_bytes*height] ;
01304     <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>** rows=<font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>*[height];
01305 
01306     <font class="keywordflow">for</font>(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i = 0;  i &lt;height;  ++i)
01307         rows[i]=image_data+i*row_bytes;
01308     png_read_image(png_ptr, rows);
01309   
01310     <font class="comment">//set rgb-data</font>
01311           XVImageWIterator&lt;T&gt; iter(I);
01312           <font class="keywordflow">for</font>( <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> j = 0; j &lt; height; ++j ){ 
01313        <font class="keywordflow">for</font>( <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i = 0; i &lt; width; ++i){
01314          (*iter).setR(rows[j][channels*i]);
01315          (*iter).setG(rows[j][channels*i+1]);
01316          (*iter).setB(rows[j][channels*i+2]);
01317          <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
01318        }
01319      }
01320   
01321     <font class="keyword">delete</font> []rows;
01322     <font class="keyword">delete</font> []image_data; 
01323  }
01324  <font class="keywordflow">else</font> {
01325     fprintf(stderr,<font class="stringliteral">"read png: un-supported color type &lt;%d&gt; in file\n"</font>, color_type);
01326     png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01327           <font class="keywordflow">return</font> -7;
01328      }
01329 
01330   png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01331 
01332   fclose(fp);
01333 
01334      <font class="keywordflow">return</font> 1;
01335 }
01336 
01337 
01338 
01339 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01340 <font class="keywordtype">int</font> XVReadPNG(<a class="code" href="class_XVImageYUV.html">XVImageYUV</a>&lt;T&gt; &amp;I, <font class="keywordtype">char</font> *fn)<font class="keyword">
</font>01341 <font class="keyword"></font>{
01342   <font class="keywordtype">char</font> buf[PNG_BYTES_TO_CHECK];
01343   png_structp png_ptr;
01344   png_infop info_ptr;
01345   <font class="keywordtype">int</font> bit_depth,  color_type, channels=0;
01346   FILE *fp;
01347 
01348      <font class="comment">// open the file</font>
01349   <font class="keywordflow">if</font> ((fp = fopen(fn, <font class="stringliteral">"rb"</font>)) == NULL)
01350      <font class="keywordflow">return</font> -1;
01351 
01352      <font class="comment">// read the file-type indicator to check if this is a PNG</font>
01353   <font class="keywordflow">if</font> (fread(buf, 1, PNG_BYTES_TO_CHECK, fp) != PNG_BYTES_TO_CHECK)
01354      <font class="keywordflow">return</font> -2;
01355 
01356      <font class="comment">// check if it is a PNG file</font>
01357   <font class="keywordflow">if</font> (png_sig_cmp((png_byte*)buf, (png_size_t)0, PNG_BYTES_TO_CHECK))
01358      <font class="keywordflow">return</font> -3;
01359 
01360   png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
01361   <font class="keywordflow">if</font> (png_ptr == NULL) {
01362      fclose(fp);
01363      <font class="keywordflow">return</font> -4;
01364   }
01365 
01366   info_ptr = png_create_info_struct(png_ptr);
01367   <font class="keywordflow">if</font> (info_ptr == NULL) {
01368     fclose(fp);
01369     png_destroy_read_struct(&amp;png_ptr, png_infopp_NULL, png_infopp_NULL);
01370     <font class="keywordflow">return</font> -5;
01371   }
01372 
01373   <font class="keywordflow">if</font> (setjmp(png_jmpbuf(png_ptr))) {
01374     <font class="comment">// Free all of the memory associated with the png_ptr and info_ptr </font>
01375     png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01376     fclose(fp);
01377     <font class="comment">// If we get here, we had a problem reading the file </font>
01378     <font class="keywordflow">return</font> -6;
01379   }
01380 
01381   png_init_io(png_ptr, fp);
01382   png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK);
01383 
01384   png_uint_32  width, height;
01385 
01386   png_read_info(png_ptr, info_ptr);  
01387 
01388   <font class="comment">// read all PNG info up to image data </font>
01389   png_get_IHDR(png_ptr, info_ptr, &amp;width, &amp;height, &amp;bit_depth, &amp;color_type,
01390       NULL, NULL, NULL);
01391   
01392   I.resize(width,height);
01393 
01394   <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_PALETTE)
01395      png_set_expand(png_ptr);
01396 
01397   <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_GRAY &amp;&amp; bit_depth &lt; 8)
01398      png_set_expand(png_ptr);
01399 
01400   <font class="keywordflow">if</font> (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
01401      png_set_expand(png_ptr);
01402 
01403   <font class="keywordflow">if</font> (bit_depth == 16)
01404      png_set_strip_16(png_ptr);
01405 
01406   <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_GRAY ||
01407      color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
01408      png_set_gray_to_rgb(png_ptr);
01409 
01410   png_read_update_info(png_ptr, info_ptr);
01411 
01412   channels = png_get_channels(png_ptr,info_ptr);
01413 
01414      <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_GRAY ||
01415       color_type == PNG_COLOR_TYPE_RGB  ||
01416          color_type == PNG_COLOR_TYPE_PALETTE) 
01417   {
01418 
01419     <font class="keywordtype">int</font> row_bytes=png_get_rowbytes(png_ptr, info_ptr);
01420     <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>*  image_data = <font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>[row_bytes*height] ;
01421     <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>** rows=<font class="keyword">new</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>*[height];
01422 
01423     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 0;  i &lt;height;  ++i)
01424         rows[i]=image_data+i*row_bytes;
01425     png_read_image(png_ptr, rows);
01426    
01427     <font class="comment">//set rgb-data</font>
01428           XVImageWIterator&lt;T&gt; iter(I);
01429           <font class="keywordflow">for</font>( <font class="keywordtype">int</font> j = 0; j &lt; height; ++j ){ 
01430        <font class="keywordflow">for</font>( <font class="keywordtype">int</font> i = 0; i &lt; width; ++i){
01431          (*iter).setY(rows[j][channels*i]);
01432          (*iter).setU(rows[j][channels*i+1]);
01433          (*iter).setV(rows[j][channels*i+2]);
01434          <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
01435        }
01436      }
01437   
01438     <font class="keyword">delete</font> []rows;
01439     <font class="keyword">delete</font> []image_data; 
01440  }
01441  <font class="keywordflow">else</font> {
01442     fprintf(stderr,<font class="stringliteral">"read png: un-supported color type &lt;%d&gt; in file\n"</font>, color_type);
01443     png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01444           <font class="keywordflow">return</font> -7;
01445      }
01446 
01447   png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01448 
01449   fclose(fp);
01450 
01451      <font class="keywordflow">return</font> 1;
01452 }
01453 
01454 
01455 <font class="comment">// this function does not handle all types of RGB images (it assumes T</font>
01456 <font class="comment">// is XV_RGBA (I believe it will work for XV_RGB too).</font>
01457 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01458 <font class="keywordtype">int</font> XVWritePNG(<font class="keyword">const</font> <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;T&gt; &amp;I, <font class="keywordtype">char</font> *fn)<font class="keyword">
</font>01459 <font class="keyword"></font>{
01460 
01461    FILE *fp;
01462    png_structp png_ptr;
01463    png_infop info_ptr;
01464 
01465    <font class="comment">/* open the file */</font>
01466    fp = fopen(fn, <font class="stringliteral">"wb"</font>);
01467    <font class="keywordflow">if</font> (fp == NULL)
01468       <font class="keywordflow">return</font> -1;
01469 
01470    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
01471 
01472    <font class="keywordflow">if</font> (png_ptr == NULL)
01473    {
01474       fclose(fp);
01475       <font class="keywordflow">return</font> -2;
01476    }
01477 
01478    <font class="comment">/* Allocate/initialize the image information data.  REQUIRED */</font>
01479    info_ptr = png_create_info_struct(png_ptr);
01480    <font class="keywordflow">if</font> (info_ptr == NULL)
01481    {
01482       fclose(fp);
01483       png_destroy_write_struct(&amp;png_ptr,  png_infopp_NULL);
01484       <font class="keywordflow">return</font> -3;
01485    }
01486 
01487    <font class="comment">/* Set error handling.  REQUIRED if you aren't supplying your own
</font>01488 <font class="comment">    * error handling functions in the png_create_write_struct() call.
</font>01489 <font class="comment">    */</font>
01490    <font class="keywordflow">if</font> (setjmp(png_jmpbuf(png_ptr)))
01491    {
01492       fclose(fp);
01493       png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
01494       <font class="keywordflow">return</font> -4;
01495    }
01496 
01497    <font class="comment">/* One of the following I/O initialization functions is REQUIRED */</font>
01498    png_init_io(png_ptr, fp);
01499 
01500 
01501    <font class="comment">/* Set the image information here.  Width and height are up to 2^31,
</font>01502 <font class="comment">    * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
</font>01503 <font class="comment">    * the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
</font>01504 <font class="comment">    * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
</font>01505 <font class="comment">    * or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
</font>01506 <font class="comment">    * PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
</font>01507 <font class="comment">    * currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
</font>01508 <font class="comment">    */</font>
01509    png_set_IHDR(png_ptr, info_ptr, I.Width(), I.Height(), 8, PNG_COLOR_TYPE_RGB,
01510       PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
01511 
01512    <font class="comment">/* flip BGR pixels to RGB */</font>
01513    png_set_bgr(png_ptr);
01514       png_set_compression_level(png_ptr,Z_BEST_COMPRESSION);
01515 
01516    <font class="comment">/* Write the file header information.  REQUIRED */</font>
01517    png_write_info(png_ptr, info_ptr);
01518 
01519       <font class="comment">// temporary fix because I could not get the RGBA image to work</font>
01520       <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;XV_RGB24&gt; tI(1,1);
01521       tI = I;
01522 
01523       png_byte* imP = (png_byte*)tI.data();
01524       png_byte** imR = (png_byte**)malloc(<font class="keyword">sizeof</font>(png_byte*)*tI.Height());
01525       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0;i&lt;tI.Height();i++) {
01526      imR[i] = imP + i*(tI.SizeX()+tI.Skip())*<font class="keyword">sizeof</font>(XV_RGB24);
01527       }
01528    png_write_image(png_ptr,imR);
01529 
01530    <font class="comment">/* You can write optional chunks like tEXt, zTXt, and tIME at the end
</font>01531 <font class="comment">    * as well.  Shouldn't be necessary in 1.1.0 and up as all the public
</font>01532 <font class="comment">    * chunks are supported and you can use png_set_unknown_chunks() to
</font>01533 <font class="comment">    * register unknown chunks into the info structure to be written out.
</font>01534 <font class="comment">    */</font>
01535 
01536    <font class="comment">/* It is REQUIRED to call this to finish writing the rest of the file */</font>
01537    png_write_end(png_ptr, info_ptr);
01538 
01539    <font class="comment">/* clean up after the write, and free any memory allocated */</font>
01540    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
01541 
01542       free(imR);
01543 
01544    <font class="comment">/* close the file */</font>
01545    fclose(fp);
01546 
01547   <font class="keywordflow">return</font> 1;
01548 }
01549 
01550 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01551 <font class="keywordtype">int</font> XVReadPNG(<a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp;I, <font class="keywordtype">char</font> *fn)<font class="keyword"> 
</font>01552 <font class="keyword"></font>{
01553   <font class="keywordtype">char</font> buf[PNG_BYTES_TO_CHECK];
01554   png_structp png_ptr;
01555   png_infop info_ptr;
01556   <font class="keywordtype">int</font> bit_depth;
01557   <font class="keywordtype">int</font> color_type;
01558   <font class="keywordtype">int</font> channels;
01559   FILE *fp;
01560   <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>** rows;
01561 
01562      <font class="comment">// open the file</font>
01563   <font class="keywordflow">if</font> ((fp = fopen(fn, <font class="stringliteral">"rb"</font>)) == NULL)
01564      <font class="keywordflow">return</font> -1;
01565 
01566      <font class="comment">// read the file-type indicator to check if this is a PNG</font>
01567   <font class="keywordflow">if</font> (fread(buf, 1, PNG_BYTES_TO_CHECK, fp) != PNG_BYTES_TO_CHECK)
01568      <font class="keywordflow">return</font> -2;
01569 
01570      <font class="comment">// check if it is a PNG file</font>
01571   <font class="keywordflow">if</font> (png_sig_cmp((png_byte*)buf, (png_size_t)0, PNG_BYTES_TO_CHECK))
01572      <font class="keywordflow">return</font> -3;
01573 
01574   png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
01575   <font class="keywordflow">if</font> (png_ptr == NULL) {
01576      fclose(fp);
01577      <font class="keywordflow">return</font> -4;
01578   }
01579 
01580   info_ptr = png_create_info_struct(png_ptr);
01581   <font class="keywordflow">if</font> (info_ptr == NULL) {
01582     fclose(fp);
01583     png_destroy_read_struct(&amp;png_ptr, png_infopp_NULL, png_infopp_NULL);
01584     <font class="keywordflow">return</font> -5;
01585   }
01586 
01587   <font class="keywordflow">if</font> (setjmp(png_jmpbuf(png_ptr))) {
01588     <font class="comment">/* Free all of the memory associated with the png_ptr and info_ptr */</font>
01589     png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01590     fclose(fp);
01591     <font class="comment">/* If we get here, we had a problem reading the file */</font>
01592     <font class="keywordflow">return</font> -6;
01593   }
01594 
01595   png_init_io(png_ptr, fp);
01596   png_set_sig_bytes(png_ptr, PNG_BYTES_TO_CHECK);
01597 
01598   png_read_png(png_ptr, info_ptr, 
01599                PNG_TRANSFORM_STRIP_ALPHA | 
01600                   PNG_TRANSFORM_PACKING |
01601                   PNG_TRANSFORM_STRIP_16
01602                , png_voidp_NULL);
01603 
01604   I.resize(png_get_image_width(png_ptr,info_ptr),png_get_image_height(png_ptr,info_ptr));
01605 
01606      <font class="comment">// here we get information about the image on disk (gray/rgb)</font>
01607   bit_depth = png_get_bit_depth(png_ptr,info_ptr);
01608   color_type = png_get_color_type(png_ptr,info_ptr);
01609   channels = png_get_channels(png_ptr,info_ptr);
01610 
01611      <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_GRAY) {
01612           XVImageWIterator&lt;T&gt; iter(I);
01613     rows = png_get_rows(png_ptr,info_ptr);
01614           <font class="keywordflow">for</font>(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> j = 0; j &lt; png_get_image_height(png_ptr,info_ptr); ++j){
01615        <font class="keywordflow">for</font>(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i = 0; i &lt; png_get_image_width(png_ptr,info_ptr); ++i){
01616          (*iter) = rows[j][i];
01617          <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
01618                }
01619           }
01620      } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (color_type == PNG_COLOR_TYPE_RGB) {
01621           <a class="code" href="class_XVImageRGB.html">XVImageRGB</a>&lt;XV_RGBA32&gt; tI(png_get_image_width(png_ptr,info_ptr),
01622                                                            png_get_image_height(png_ptr,info_ptr));
01623           XVImageWIterator&lt;XV_RGBA32&gt; iter(tI);
01624     rows = png_get_rows(png_ptr,info_ptr);
01625           <font class="keywordflow">for</font>(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> j = 0; j &lt; png_get_image_height(png_ptr,info_ptr); ++j){
01626        <font class="keywordflow">for</font>(<font class="keywordtype">unsigned</font> <font class="keywordtype">int</font> i = 0; i &lt; png_get_image_width(png_ptr,info_ptr); ++i){
01627          (*iter).setR(rows[j][channels*i]);
01628          (*iter).setG(rows[j][channels*i+1]);
01629          (*iter).setB(rows[j][channels*i+2]);
01630          <font class="keywordflow">if</font>(!iter.end()){ ++iter; }
01631        }
01632      }
01633           RGBtoScalar(tI,I);
01634      } <font class="keywordflow">else</font> {
01635     fprintf(stderr,<font class="stringliteral">"read png: un-supported color type in file\n"</font>);
01636     png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01637           <font class="keywordflow">return</font> -7;
01638      }
01639 
01640   png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, png_infopp_NULL);
01641 
01642   fclose(fp);
01643 
01644   <font class="keywordflow">return</font> 1;
01645 }
01646 
01647 <font class="keyword">template</font> &lt;<font class="keyword">class </font>T&gt;
01648 <font class="keywordtype">int</font> XVWritePNG(<font class="keyword">const</font> <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;T&gt; &amp;I, <font class="keywordtype">char</font> *fn)<font class="keyword">
</font>01649 <font class="keyword"></font>{
01650    FILE *fp;
01651    png_structp png_ptr;
01652    png_infop info_ptr;
01653 
01654    <font class="comment">/* open the file */</font>
01655    fp = fopen(fn, <font class="stringliteral">"wb"</font>);
01656    <font class="keywordflow">if</font> (fp == NULL)
01657       <font class="keywordflow">return</font> -1;
01658 
01659    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
01660 
01661    <font class="keywordflow">if</font> (png_ptr == NULL)
01662    {
01663       fclose(fp);
01664       <font class="keywordflow">return</font> -2;
01665    }
01666 
01667    <font class="comment">/* Allocate/initialize the image information data.  REQUIRED */</font>
01668    info_ptr = png_create_info_struct(png_ptr);
01669    <font class="keywordflow">if</font> (info_ptr == NULL)
01670    {
01671       fclose(fp);
01672       png_destroy_write_struct(&amp;png_ptr,  png_infopp_NULL);
01673       <font class="keywordflow">return</font> -3;
01674    }
01675 
01676    <font class="comment">/* Set error handling.  REQUIRED if you aren't supplying your own
</font>01677 <font class="comment">    * error handling functions in the png_create_write_struct() call.
</font>01678 <font class="comment">    */</font>
01679    <font class="keywordflow">if</font> (setjmp(png_jmpbuf(png_ptr)))
01680    {
01681       fclose(fp);
01682       png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
01683       <font class="keywordflow">return</font> -4;
01684    }
01685 
01686    <font class="comment">/* One of the following I/O initialization functions is REQUIRED */</font>
01687    png_init_io(png_ptr, fp);
01688 
01689 
01690    <font class="comment">/* Set the image information here.  Width and height are up to 2^31,
</font>01691 <font class="comment">    * bit_depth is one of 1, 2, 4, 8, or 16, but valid values also depend on
</font>01692 <font class="comment">    * the color_type selected. color_type is one of PNG_COLOR_TYPE_GRAY,
</font>01693 <font class="comment">    * PNG_COLOR_TYPE_GRAY_ALPHA, PNG_COLOR_TYPE_PALETTE, PNG_COLOR_TYPE_RGB,
</font>01694 <font class="comment">    * or PNG_COLOR_TYPE_RGB_ALPHA.  interlace is either PNG_INTERLACE_NONE or
</font>01695 <font class="comment">    * PNG_INTERLACE_ADAM7, and the compression_type and filter_type MUST
</font>01696 <font class="comment">    * currently be PNG_COMPRESSION_TYPE_BASE and PNG_FILTER_TYPE_BASE. REQUIRED
</font>01697 <font class="comment">    */</font>
01698       <font class="comment">// assume u_char</font>
01699    png_set_IHDR(png_ptr, info_ptr, I.Width(), I.Height(), 8, PNG_COLOR_TYPE_GRAY,
01700       PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
01701 
01702       png_set_compression_level(png_ptr,Z_BEST_COMPRESSION);
01703 
01704    <font class="comment">/* Write the file header information.  REQUIRED */</font>
01705    png_write_info(png_ptr, info_ptr);
01706 
01707       <font class="comment">// temporary fix, too</font>
01708       <a class="code" href="class_XVImageScalar.html">XVImageScalar</a>&lt;u_char&gt; tI(1,1);
01709       tI = I;
01710 
01711       png_byte* imP = (png_byte*)tI.data();
01712       png_byte** imR = (png_byte**)malloc(<font class="keyword">sizeof</font>(png_byte*)*tI.Height());
01713       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0;i&lt;tI.Height();i++) {
01714      imR[i] = imP + i*(tI.SizeX()+tI.Skip());
01715       }
01716    png_write_image(png_ptr,imR);
01717 
01718    <font class="comment">/* You can write optional chunks like tEXt, zTXt, and tIME at the end
</font>01719 <font class="comment">    * as well.  Shouldn't be necessary in 1.1.0 and up as all the public
</font>01720 <font class="comment">    * chunks are supported and you can use png_set_unknown_chunks() to
</font>01721 <font class="comment">    * register unknown chunks into the info structure to be written out.
</font>01722 <font class="comment">    */</font>
01723 
01724    <font class="comment">/* It is REQUIRED to call this to finish writing the rest of the file */</font>
01725    png_write_end(png_ptr, info_ptr);
01726 
01727    <font class="comment">/* clean up after the write, and free any memory allocated */</font>
01728    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
01729 
01730       free(imR);
01731 
01732    <font class="comment">/* close the file */</font>
01733    fclose(fp);
01734 
01735   <font class="keywordflow">return</font> 1;
01736 }
01737 
01738 <font class="preprocessor">#endif
</font>01739 <font class="preprocessor"></font>
01740 
01741 <font class="preprocessor">#endif
</font></div></pre><hr><address><small>Generated at Fri Oct 26 00:17:16 2007 for XVision by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
